import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { intrParcticeArr } from '../practice/index';

export const meta = {};


# 类型就是数据

每种编程语言都是关于**转换数据**的，Type-level TypeScript 也不例外。与其他编程语言的主要区别在于我们的数据是**类型**！我们编写将类型作为输入并输出一些其他类型的程序。

掌握这门语言需要你深入的理解它的不同数据和不同数据结构的特性。在接下来几章中，我们将学习它们并了解它们与我们常用的 value-level 的概念之间的关联。让我们开始吧！

## 五种类型

TypeScript 提供了五种主要的类型：**基础**类型、**字面量**类型、**数据结构**类型、**联合**类型和**交集**类型。

### 基础类型

你肯定已经非常熟悉基础类型了。我们一直使用它们来注释我们日常 TypeScript 代码中的变量和函数。以下是原始类型的列表：

```ts
type Primitives =
  | number
  | string
  | boolean
  | symbol
  | bigint
  | undefined
  | null;
```

JavaScript 里除了对象和函数以外的其他值，都属于基础类型。某些基础类型拥有无限个值，像 number 和 string ，但是其中 null 和 undefined 类型只拥有一个值。 这些特性同时造就了我们第二种类型：**字面量类型**。

### 字面量类型


字面量类型是“精确”类型，只包含**一个可能的值**。

```ts
type Literals =
  | 20
  | "Hello"
  | true
  | 10000n
  /* | ... */;
```

类型为20的变量只能被赋值为20，类型为 "Hello" 的变量只能被赋值为 "Hello"，等等。

```ts
const twenty: 20 = 20; // ✅ works!
const hundred: 20 = 100;
//          ^ ❌ `100` isn't assignable to the type `20`.
```

字面量类型有无数种，它们看起来就像普通的值，但是不要搞混了，它们都是类型！

**值和类型属于两个完全不同的世界** —— 他们彼此独立存在，在单个表达式里不能被混在一起[^1]。 我发现，如果我们将字面量类型视为类型世界里值的一种映射，将会很有帮助。但是需要时刻记住，类型和值它们是不同的东西。一个显著的区别是，我们无法在 type-level 书写数学表达式。比如，`type five = 2 + 3` 是完全无效的，但是 `const five = 2 + 3` 是完全有效的。

当放在联合类型中来描述一组有限可能的类型时，字面量类型非常有用，比如 `type TrafficLight = "green" | "orange" | "red"` 。

### 数据结构类型

在 type-level 世界里，我们拥有四种内置的数据结构可供使用：**objects**, **records**, **tuples** and **arrays**。

```ts
type DataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
```

- **Object** 类型用于描述一组有限健值的对象，这些键可能包含不同类型的值。
- **Record** 类型和 **Object** 类型相似，不同之处在于它描述拥有未知数量的健值的对象，并且所有健的值的类型都是相同的。比如，在`{ [key: string]: number }`里，所有值类型都是 number 。
- **Tuple** 类型用于描述固定长度的数组，每个索引可以对应不同的值。
- **Array** 类型用于描述长度不定的数组，和 **Record** 类型一样，其中所有的值都是相同类型的。

在接下来的章节中，我们将花更多时间学习它们。

### 联合类型和交叉类型

到目前为止，我们所看到的一切都与 value-level 中所用到的概念相似，但是联合类型和交叉类型不一样。它们只存在于 type-level 世界，建立一个良好的心智模型来学习它们是非常重要的，尽管这充满着挑战。

它们看起来像这样：

```ts
type Union = X | Y;

type Intersection = X & Y;
```

简单来说，你可以理解联合类型 `X | Y` 为“一个值的类型要么属于类型 **X** 要么属于类型 **Y**”，交叉类型 `X & Y` 为“一个值的类型即属于类型 **X** 又属于类型 **Y**”。

我们倾向于把 `｜` 和 `&` 视为操作符，但是事实上，它们也是数据结构。

创建联合类型 `X | Y` 不会像操作符那样创建一个新的不透明的类型。相反，它将 `X` 和 `Y` 按序放在一个盒子里，之后我们可以从中**提取**它们。在接下来的章节里，我们将会看到，我们甚至可以**遍历**联合类型中的每种类型。考虑到这点， `|` 看起来更像是一种将类型添加到某种 **“联合”数据结构** 的方法。但它到底是什么？

好吧，我们可以说 type-level 中的联合类型等价于 Javascript 中的 Set ， 但实际上的情况更复杂一些。为了更好的掌握联合类型和交叉类型，我需要介绍一个 type-level 中的基础概念：**所有类型都是集合**。

### 类型就是集合

TypeScript 的一个有趣特性是一个值可以属于多个类型。例如，值 2 可以赋给 `number` 类型的变量，也可以赋给 `2` 类型的变量，甚至是 `1 | 2 | 3` 类型的变量. 此特性称之为**子类型**。这意味着类型可以包含在其他类型中，或者换句话说，类型可以是其他类型的**子集**。

那意味着，不仅仅是集合，其它所有类型都是集合！类型可以**包含**其它类型，相互**重叠**或者相互**排斥**。

例如，字面量 `"H1"` 和 字面量 `"Hello"` 都被 `string` 类型所包含，因为它们都是组成 `strings` 这个大家庭中的一部分：

![1](./img/02-types-are-just-data/1.svg)

我们说 `“Hi”` 和 `“Hello”` 是 `string` 的子类型，而 `string` 是它们的超类型。这意味着您可以将 `“Hi”` 或 `“Hello”` 类型的变量分配给 `string` 类型的变量，但反过来不行：

```ts
let hi: "Hi" = "Hi";
let hello: "Hello" = "Hello";

let greeting: string;

greeting = hi; // ✅ type-checks!
greeting = hello; // ✅ type-checks!

hello = greeting; // ❌ doesn't type-check!
```

我们也可以说 `"H1"` 和 `"H1"` 可以**分配**给 `string` 类型。

**可分配** 这个概念在 Typescript 中无处不在。大多数的类型错误都会告诉你，这个类型不能分配给其它类型。当你开始认为类型就是集合时，可分配性变得更加直观 —— **“ A 可以分配给 B ”** 意味着 **“集合 B 包含所有 集合 A 中的值”** 或者 **“集合 A 是集合 B 的子集”**

`string` 类型和 `number` 类型是互斥的：它们没有重叠的部分，因为没有值同时属于它们两个集合。

![2](./img/02-types-are-just-data/2.svg)


这就是为什么你不能将 `string` 类型的变量分配给 `number` 类型的变量，反之亦然：

```ts
let greeting: string = "Hello";
let age: number = greeting; // ❌ doesn't type-check.
```

最后，两种类型有时会**部分重叠**。在这种情况下，它们既不互斥也不具有子类型关系：

![3](./img/02-types-are-just-data/3.svg)

这通常发生在使用联合类型时。例如类型 `"green" | "orange"` 和类型 `"orange" | "red"` 是部分重叠的！

![4](./img/02-types-are-just-data/4.svg)

让我们为这两种联合类型命名：

```ts
type CanCross = "green" | "orange";
type ShouldStop = "orange" | "red";
```

现在，我们可以思考一下，`CanCross` 类型的变量分配给 `ShouldStop` 类型的变量吗？

```ts
let canCross = "orange" as CanCross; // ✅
let shouldStop = "orange" as ShouldStop; // ✅
canCross = shouldStop;
//       ❌ ~~~~~~~~~ type 'red' isn't assignable to the type `green` | 'orange'
shouldStop = canCross;
//         ❌ ~~~~~~~ type 'green' isn't assignable to the type `orange` | 'red'
```

不能。即使 `CanCross` 和 `ShouldStop` 都包含 `string` 类型 `"orange"` ，我们也不能将 `CanCross` 类型的变量分配给 `ShouldStop` 类型，因为它们没有完全重叠。

在上面的例子中，我们可以清楚的看到， `canCross` 和 `shouldStop` 都包含值 `"orange"` ，但是你不能把它赋值给另一个，这可能很违反直觉。请记住， Typescript 并不知道变量包含什么值，它只知道它的类型！

## 联合类型-集合的并集

如果你了解一点集合的理论知识，你就会知道两个集合的并集是包含这两个集合的集合，所以 `A | B` 类型包含了所有 `A` 类型和 `B` 类型中的所有可能值。 

![5](./img/02-types-are-just-data/5.svg)

我们可以将任意两个集合合并，包括其它的联合类型！例如，我们可以将上一个示例中的 `CanCross` 和 `ShouldStop` 合并为 `TrafficLight` 类型：

![6](./img/02-types-are-just-data/6.svg)

```ts
// this is equivalent to "green" | "orange" | "red"
type TrafficLight = CanCross | ShouldStop;

let canCross: CanCross = "green";
let shouldStop: ShouldStop = "red";

let trafficLight: TrafficLight;
trafficLight = shouldStop; // ✅
trafficLight = canCross; // ✅
```

`TrafficLight` 类型是 `CanCross` 和 `ShouldStop` 的**超集**。需要注意， `"orange"` 在 `TrafficLight` 类型中只有一个。这是因为集合类型不能出现重复项，所以联合类型也不能包含重复项。

联合类型有助于创建明确的类型的**嵌套层次结构**。并且我们总是可以将两种类型放在一个联合类型中，因此我们可以创建任意数量的子类型级别：

![7](./img/02-types-are-just-data/7.svg)

此时，你可能会想，如果所有类型都可以属于其他类型，那么这种嵌套类型的层次结构往上到哪里为止呢？有没有一种终极类型，包含了**所有其它的类型**？

嗯，有这样一种类型，它叫 `unkown` 。

## `unknown` — 所有类型的超集

`unknown` 包含了你在 Typescript 中使用的所有类型。

![8](./img/02-types-are-just-data/8.svg)

您可以将任何内容分配给 `unknown` 类型的变量：

```ts
let something: unknown;

something = "Hello";            // ✅
something = 2;                  // ✅
something = { name: "Alice" };  // ✅
something = () => "?";          // ✅
```

这很不错，但是这也意味着你不能对类型为 `unkown` 的变量做很很多其它操作，因为 Typescript 并不知道它包含了什么值！

```ts
let something: unknown;

something = "Hello";
something.toUpperCase();
//       ^ ❌ Property 'toUpperCase' does not exist
//            on type 'unknown'.
```

任何类型 `A` 与 `unkown` 类型进行合并，总是会得到 `unkown` 类型。这是合理的，因为根据定义，类型 `A` 肯定包含在 `unkown` 里：

```ts
A | unknown = unknown
```

![9](./img/02-types-are-just-data/9.svg)

但是如果取交集呢？

任何类型 `A` 和 `unkown` 类型进行交集运算会得到类型 `A`：

```ts
A & unknown = A
```

那是因为将集合 `A` 与集合 `B` 相交意味着提取 `A` 中也属于 `B` 的部分！由于任何类型 `A` 都在 `unknown` 内部，因此 `A & unknown` 就是 `A`。

![10](./img/02-types-are-just-data/10.svg)

## 交叉类型

交叉类型和联合类型正好相反：`A & B` 是**同时属于 `A` 和 `B`** 的所有值的类型：

![11](./img/02-types-are-just-data/11.svg)

交叉类型用来处理对象类型很方便，因为对象类型 `A` 和 对象类型 `B` 的交集是具有 `A` 所有属性和 `B` 所有属性的对象集合：

![12](./img/02-types-are-just-data/12.svg)

这就是为什么我们有时会使用联合类型来将对象类型合并在一起[^2]：

```ts
type WithName = { name: string };
type WithAge = { age: number };

function someFunction(input: WithName & WithAge) {
  // `input` is both a `WithName` and a `WithAge`!
  input.name; // ✅ property `name` has type `string`
  input.age; // ✅ property `age` has type `number`
}
```

但是，如果我们尝试将两种完全不重叠的类型相交会发生什么？例如，将 `string` 和 `number` 相交意味着什么？

![13](./img/02-types-are-just-data/13.svg)

看起来 `string & number` 会给我们带来某种类型错误，但事实上，这对类型检查器来说很重要！不重叠的相交类型的结果是**空集**。一个**不包含任何东西的集合**。

在 TypeScript 中，空集被称为 `never`。

## `never` — 空集

The type never doesn't contain any value, so we can use it to represent values that should never exist at runtime. For instance, a function that always throws will return a value of type never:

`never` 类型不包含任何值，因此我们可以使用它来表示在运行时不应该存在的值。例如，一个总是抛出异常的函数将返回一个 `never` 类型的值：

```ts
function panic(): never {
  throw new Error("🙀");
}

const oops: never = panic();
```

That's because the code using oops can never be reached!

That's good to know, but never doesn't sound very useful in practice, don't you think?

You would be surprised! We use never all the time when writing type-level code. never is essentially an empty union type. Having an empty type is immensely useful for type-level logic. We will use it to remove keys from object types, filter out items from a union, represent impossible cases, etc.

An interesting property of never is that it's a subtype of every other types — it's at the very bottom of our hierarchy of sets. That means you can assign a value of type never to any other type:

Edit


## 脚注

[^1]: This is true in TypeScript, but some languages do allow mixing values and types together in the same expression and the line between the world of values and the world of types becomes blurrier. They are called "dependent" type systems.


[^2]: Intersecting two object types is not exactly like merging two objects with `{...a, ...b}`, the way we would in JavaScript, because the intersection is applied recursively on keys that exist on both object types. We will learn more about intersections of objects in the next chapter.

export default ({ children }) => (
  <PageLayout meta={meta}>{children}</PageLayout>
);
