import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { intrParcticeArr } from '../practice/index';

export const meta = {};


# 类型就是数据

每种编程语言都是关于**转换数据**的，Type-level TypeScript 也不例外。与其他编程语言的主要区别在于我们的数据是**类型**！我们编写将类型作为输入并输出一些其他类型的程序。

掌握这门语言需要你深入的理解它的不同数据和不同数据结构的特性。在接下来几章中，我们将学习它们并了解它们与我们常用的 value-level 的概念之间的关联。让我们开始吧！

## 五种类型

TypeScript 提供了五种主要的类型：**基础**类型、**字面量**类型、**数据结构**类型、**联合**类型和**交集**类型。

### 基础类型

你肯定已经非常熟悉基础类型了。我们一直使用它们来注释我们日常 TypeScript 代码中的变量和函数。以下是原始类型的列表：

```ts
type Primitives =
  | number
  | string
  | boolean
  | symbol
  | bigint
  | undefined
  | null;
```

JavaScript 里除了对象和函数以外的其他值，都属于基础类型。某些基础类型拥有无限个值，像 number 和 string ，但是其中 null 和 undefined 类型只拥有一个值。 这些特性同时造就了我们第二种类型：**字面量类型**。

### 字面量类型


字面量类型是“精确”类型，只包含**一个可能的值**。

```ts
type Literals =
  | 20
  | "Hello"
  | true
  | 10000n
  /* | ... */;
```

类型为20的变量只能被赋值为20，类型为 "Hello" 的变量只能被赋值为 "Hello"，等等。

```ts
const twenty: 20 = 20; // ✅ works!
const hundred: 20 = 100;
//          ^ ❌ `100` isn't assignable to the type `20`.
```

字面量类型有无数种，它们看起来就像普通的值，但是不要搞混了，它们都是类型！

**值和类型属于两个完全不同的世界** —— 他们彼此独立存在，在单个表达式里不能被混在一起[^1]。 我发现，如果我们将字面量类型视为类型世界里值的一种映射，将会很有帮助。但是需要时刻记住，类型和值它们是不同的东西。一个显著的区别是，我们无法在 type-level 书写数学表达式。比如，`type five = 2 + 3` 是完全无效的，但是 `const five = 2 + 3` 是完全有效的。

当放在联合类型中来描述一组有限可能的类型时，字面量类型非常有用，比如 `type TrafficLight = "green" | "orange" | "red"` 。

### 数据结构类型

在 type-level 世界里，我们拥有四种内置的数据结构可供使用：**objects**, **records**, **tuples** and **arrays**。

```ts
type DataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
```

- **Object** 类型用于描述一组有限健值的对象，这些键可能包含不同类型的值。
- **Record** 类型和 **Object** 类型相似，不同之处在于它描述拥有未知数量的健值的对象，并且所有健的值的类型都是相同的。比如，在`{ [key: string]: number }`里，所有值类型都是 number 。
- **Tuple** 类型用于描述固定长度的数组，每个索引可以对应不同的值。
- **Array** 类型用于描述长度不定的数组，和 **Record** 类型一样，其中所有的值都是相同类型的。

在接下来的章节中，我们将花更多时间学习它们。

### 联合类型和交叉类型

Everything we have seen so far looks somewhat similar to concepts we are used to at the value level, but unions and intersections are different. They are really specific to the type level, and building a good mental model of how they work is essential, although a little more challenging.

到目前为止，我们所看到的一切都与 value-level 中所用到的概念相似，但是联合类型和交叉类型不一样。它们只存在于 type-level 世界，建立一个良好的心智模型来学习它们是非常重要的，尽管这充满着挑战。

它们看起来像这样：

```ts
type Union = X | Y;

type Intersection = X & Y;
```


### 交集类型



## 脚注

[^1]: This is true in TypeScript, but some languages do allow mixing values and types together in the same expression and the line between the world of values and the world of types becomes blurrier. They are called "dependent" type systems.


[^2]: Intersecting two object types is not exactly like merging two objects with `{...a, ...b}`, the way we would in JavaScript, because the intersection is applied recursively on keys that exist on both object types. We will learn more about intersections of objects in the next chapter.

export default ({ children }) => (
  <PageLayout meta={meta}>{children}</PageLayout>
);
