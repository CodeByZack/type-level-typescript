import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { intrParcticeArr } from '../practice/index';

export const meta = {};


# 类型就是数据

每种编程语言都是关于**转换数据**的，Type-level TypeScript 也不例外。与其他编程语言的主要区别在于我们的数据是**类型**！我们编写将类型作为输入并输出一些其他类型的程序。

掌握这门语言需要你深入的理解它的不同数据和不同数据结构的特性。在接下来几章中，我们将学习它们并了解它们与我们常用的 value-level 的概念之间的关联。让我们开始吧！

## 五种类型

TypeScript 提供了五种主要的类型：**基础**类型、**字面量**类型、**数据结构**类型、**联合**类型和**交集**类型。

### 基础类型

你肯定已经非常熟悉基础类型了。我们一直使用它们来注释我们日常 TypeScript 代码中的变量和函数。以下是原始类型的列表：

```ts
type Primitives =
  | number
  | string
  | boolean
  | symbol
  | bigint
  | undefined
  | null;
```

JavaScript 里除了对象和函数以外的其他值，都属于基础类型。某些基础类型拥有无限个值，像 number 和 string ，但是其中 null 和 undefined 类型只拥有一个值。 这些特性同时造就了我们第二种类型：**字面量类型**。

### 字面量类型


字面量类型是“精确”类型，只包含**一个可能的值**。

```ts
type Literals =
  | 20
  | "Hello"
  | true
  | 10000n
  /* | ... */;
```

类型为20的变量只能被赋值为20，类型为 "Hello" 的变量只能被赋值为 "Hello"，等等。

```ts
const twenty: 20 = 20; // ✅ works!
const hundred: 20 = 100;
//          ^ ❌ `100` isn't assignable to the type `20`.
```

字面量类型有无数种，它们看起来就像普通的值，但是不要搞混了，它们都是类型！

Values and types belong to two different worlds — they exist separately and can't be mixed together in a single expression1. I find it helpful to see literal types as a sort of reflection of values in the world of types, but we need to keep in mind that they are different things. One notable difference is that we can't write arithmetic expressions at the type level. For instance type five = 2 + 3 won't work, even if const five = 2 + 3 is perfectly valid.

值和类型属于两个完全不同的世界 —— 他们彼此独立存在，在单个表达式里不能被混在一起[^1]。 




Literal types become particularly useful when put in unions to describe variables that only contain a finite set of possible values like type TrafficLight = "green" | "orange" | "red".



### 数据结构类型

### 联合类型

### 交集类型



## 脚注

[^1]: This is true in TypeScript, but some languages do allow mixing values and types together in the same expression and the line between the world of values and the world of types becomes blurrier. They are called "dependent" type systems.


[^2]: Intersecting two object types is not exactly like merging two objects with `{...a, ...b}`, the way we would in JavaScript, because the intersection is applied recursively on keys that exist on both object types. We will learn more about intersections of objects in the next chapter.

export default ({ children }) => (
  <PageLayout meta={meta}>{children}</PageLayout>
);
