import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { tavPracticeArr } from '../practice/index';
import { PostArrary } from '../postInfos';

export const meta = {};

# Objects & Records

åœ¨ Type-level TypeScript ä¸­ï¼ŒObjects å’Œ Records æ˜¯ä¸¤ç§æœ€å¸¸ç”¨çš„**æ•°æ®ç»“æ„**ã€‚å®ƒä»¬æ˜¯æˆ‘ä»¬ type-level **ç®—æ³•**çš„åŸºç¡€ï¼Œäº†è§£å®ƒä»¬çš„å·¥ä½œåŸç†ååˆ†é‡è¦ã€‚æˆ‘èƒ½è‚¯å®šä½ æ—©å·²ä½¿ç”¨è¿‡ Objects å’Œ Records ï¼Œä½†æˆ‘å¸Œæœ›æœ¬ç« èƒ½åŠ æ·±ä½ å¯¹å®ƒä»¬ä»£è¡¨çš„æ„ä¹‰çš„**ç†è§£**ï¼Œä»¥åŠå±•ç¤ºä¸€äº›**ä¸å¸¸ç”¨çš„ä½¿ç”¨åœºæ™¯**ã€‚

```ts
type SomeObject = { key1: boolean; key2: number };

type SomeRecord = { [key: string]: number };
```

åœ¨æˆ‘ä»¬å¼€å§‹ä¹‹å‰ï¼Œè®©æˆ‘å†æ¬¡æé†’ä½ ä¸€ä¸‹ï¼Œæˆ‘ä»¬[ä¸Šä¸€ç« èŠ‚](/02-types-are-just-data)è®¨è®ºè¿‡çš„é‡è¦æ¦‚å¿µã€‚åœ¨æ·±å…¥æ¢è®¨[ç±»å‹å’Œé›†åˆç†è®ºä¹‹é—´çš„å…³ç³»](/02-types-are-just-data#types-are-sets)ä¹‹å‰ï¼Œæˆ‘ä»¬ç®€è¦ä»‹ç»äº†ç±»å‹çš„**äº”ä¸ªä¸»è¦ç±»åˆ«** â€”â€” **åŸºç¡€**ç±»å‹ã€**å­—é¢é‡**ç±»å‹ã€**æ•°æ®ç»“æ„**ç±»å‹ã€**è”åˆ**ç±»å‹å’Œ**äº¤é›†**ç±»å‹ã€‚

æˆ‘ä»¬å‘ç°**ç±»å‹ä»£è¡¨ä¸€ç»„å€¼**ã€‚å°±åƒé›†åˆä¸€æ ·ï¼Œç±»å‹å¯ä»¥åŒ…å«å…¶ä»–ç±»å‹ï¼Œæˆ‘ä»¬æŠŠè¿™ç§å…³ç³»ç§°ä¹‹**å­ç±»å‹**ã€‚

![1](./img/03-objects-and-records/1.svg)

æœ€åï¼Œæˆ‘ä»¬å­¦ä¹ äº†ä¸¤ç§ç‰¹æ®Šçš„ç±»å‹ï¼š `never` - **ç©ºé›†**ï¼Œ å’Œ `unkown` - **å…¶å®ƒæ‰€æœ‰ç±»å‹çš„è¶…é›†**ã€‚

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å…³æ³¨ä¸Šä¸€ç« èŠ‚ä¸­æåˆ°çš„**å››ç§æ•°æ®ç»“æ„ç±»å‹**ä¸­çš„**ä¸¤ç§**ï¼š**Objects** å’Œ **Records** ï¼š

```ts
type FourKindsOfDataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
```

## Object ç±»å‹

Object ç±»å‹å®šä¹‰ **JavaScript çš„å¯¹è±¡é›†åˆ**ã€‚åˆ›å»º Object ç±»å‹çš„è¯­æ³•ä¸æˆ‘ä»¬åˆ›å»ºå¸¸è§„å¯¹è±¡çš„æ–¹å¼éå¸¸ç›¸ä¼¼ï¼š

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};
```

äº‹å®ä¸Šï¼Œå®ƒä»¬æ˜¯ JS å¯¹è±¡åœ¨ type-level çš„ç­‰ä»·ç‰©ã€‚å°±åƒ JS å¯¹è±¡ä¸€æ ·ï¼Œå®ƒå¯ä»¥åŒ…å«æˆ‘ä»¬æƒ³è¦çš„ä»»æ„æ•°é‡çš„å±æ€§ï¼Œå¹¶ä¸”æ¯ä¸ªå±æ€§éƒ½ç”±ä¸€ä¸ª**å”¯ä¸€çš„é”®**ç´¢å¼•ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯ä¸ªé”®å¯ä»¥åŒ…å«**ä¸åŒ**çš„ç±»å‹ï¼š `name` é”®åŒ…å« `string` ç±»å‹ï¼Œ `age` é”®åŒ…å« `numner` ç±»å‹ã€‚

æˆ‘ä»¬åˆ›å»ºçš„ `User` ç±»å‹æ˜¯å…·æœ‰`name`ã€`age` å’ŒåŒ…å«æ­£ç¡®ç±»å‹å€¼çš„ `role` å±æ€§çš„æ‰€æœ‰å¯¹è±¡çš„é›†åˆï¼š

```ts
// âœ… this object is in the `User` set.
const gabriel: User = {
  name: "Gabriel",
  role: "admin",
  age: 28,
};

// âŒ
const bob: User = {
  name: "Bob",
  age: 45,
  // <- the `role` key is missing.
};

// âŒ
const peter: User = {
  name: "Peter",
  role: "standard",
  age: "45" /* <- the `age` key should be of type `number`,
                   but it's assigned to a `string`. */,
};
```

**ä½†æ˜¯å…·æœ‰é¢å¤–å±æ€§çš„å¯¹è±¡å‘¢**ï¼Ÿå®ƒä»¬å¯ä»¥åˆ†é…ç»™æˆ‘ä»¬çš„ `User` ç±»å‹å—ï¼Ÿ

å—¯ï¼Œ**å¯ä»¥â€¦â€¦ä¹Ÿä¸å¯ä»¥**ã€‚è®©æˆ‘è§£é‡Šä¸€ä¸‹ï¼

## å¯¹è±¡çš„å¯åˆ†é…æ€§

å¦‚æœæ‚¨å°è¯•å°†å¯¹è±¡åˆ†é…ç»™å…·æœ‰æ˜¾å¼ç±»å‹æ³¨é‡Šçš„å˜é‡ï¼Œå°±åƒæˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢æ‰€åšçš„é‚£æ ·ï¼ŒTypeScript å°†**æ‹’ç»**é¢å¤–çš„å±æ€§ï¼š

```ts
const alice: User = {
  name: "Alice",
  age: 35,
  role: "admin",
  bio: "...",
/* ~~~~~~~~~  
       ^  âŒ This doesn't type-check. */
};
```

è¿™æ˜¯ä½ å°†å¾—åˆ°çš„å®Œæ•´é”™è¯¯ï¼š

```ts
Object literal may only specify known properties, and 'bio' does not exist in type 'User'. (2322)
```

**å¯¹è±¡å­—é¢é‡**æŒ‡çš„æ˜¯ä½ ä½¿ç”¨å¤§æ‹¬å· `{}` è¯­æ³•**å…§è”**å®šä¹‰çš„å¯¹è±¡ã€‚

å¦‚æœæˆ‘ä»¬å°†å…·æœ‰é¢å¤–å±æ€§çš„ï¼Œ**é¢„å…ˆå®šä¹‰å¥½çš„**å¯¹è±¡èµ‹å€¼ç»™ `alice` ä¼šæŠ¥é”™å—ï¼Ÿ

```ts
const looksLikeAUser = {
  name: "Alice",
  age: 35,
  role: "admin" as const,
  bio: "...", // <- extra prop!
};

// âœ… This works just fine!
const alice: User = looksLikeAUser;
```

TypeScript ä¸ä¼šæŠ¥é”™ã€‚

æ‰€ä»¥æœ€ç»ˆçš„ç­”æ¡ˆæ˜¯**å…·æœ‰é¢å¤–å±æ€§çš„å¯¹è±¡å¯ä»¥åˆ†é…ç»™å…·æœ‰æ›´å°‘å±æ€§çš„å¯¹è±¡**ï¼Œä½†æ˜¯åœ¨**å¯¹è±¡è¢«å†…è”å®šä¹‰**çš„ä¸Šä¸‹æ–‡ä¸­ï¼ŒTypeScript æœ‰**é¢å¤–çš„è§„åˆ™**æ¥ç¡®ä¿æˆ‘ä»¬ä¸ä¼šé”™è¯¯åœ°åˆ†é…æˆ‘ä»¬ä¹‹åæ— æ³•ä½¿ç”¨çš„å±æ€§ï¼Œå› ä¸ºç±»å‹æ£€æŸ¥ä¼šç¦æ­¢æˆ‘ä»¬è¿™æ ·åšã€‚

![2](./img/03-objects-and-records/2.svg)

è¿™æ„å‘³ç€ï¼Œä½ **ä¸èƒ½ä¿è¯**æŸç§ç±»å‹çš„å¯¹è±¡**ä¸åŒ…å«**é¢å¤–çš„å±æ€§ï¼[^1] ä¸€ä¸ª Object ç±»å‹æ˜¯ä¸€ä¸ª**è‡³å°‘**åŒ…å«å®ƒæ‰€å®šä¹‰çš„æ‰€æœ‰å±æ€§çš„å¯¹è±¡çš„é›†åˆã€‚

ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ï¼Œå¯ä»¥ç”¨ type-level çš„å¯¹è±¡åšäº›ä»€ä¹ˆï¼Ÿ

## è¯»å–å±æ€§

è¦è®¿é—®ä¸€ä¸ªå±æ€§çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·ï¼š

```ts
type User = { name: string; age: number; role: "admin" | "standard" };

type Age = User["age"]; // => number
type Role = User["role"]; // => "admin" | "standard"
```

ä½†æ˜¯ç‚¹ä¸ä¼šèµ·ä½œç”¨ï¼

```ts
type Age = User.age;
//             ^ âŒ syntax error!
```

æ²¡å…³ç³»ã€‚æ— è®ºå¦‚ä½•ï¼Œæ–¹æ‹¬å·è¡¨ç¤ºæ³•å’Œç‚¹è¡¨ç¤ºæ³•åœ¨ value-level ä¸Šæ˜¯ç­‰ä»·çš„ã€‚

## ä¸€æ¬¡è¯»å–å¤šä¸ªå±æ€§

æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œåœ¨ `User["age"]` ç­‰è¡¨è¾¾å¼ä¸­ï¼Œé”® (`"age"`) æ˜¯[**å­—é¢é‡ç±»å‹**](/02-types-are-just-data#literal-types)ã€‚å¦‚æœæ‚¨å°è¯•ä½¿ç”¨**è”åˆç±»å‹**ï¼Œä½ è®¤ä¸ºä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

```ts
type User = { name: string; age: number; role: "admin" | "standard" };

type NameOrAge = User["name" | "age"]; // => string | number
```

å—¯ï¼Œå®ƒæ˜¯æœ‰æ•ˆçš„ï¼å°±å¥½åƒæˆ‘ä»¬**åŒæ—¶**è®¿é—® `"name"` å’Œ `"age"` å±æ€§ä¸€æ ·ï¼Œç„¶åä¼šå¾—åˆ°ä¸€ä¸ªåŒ…å«å®ƒä»¬çš„ç±»å‹çš„è”åˆç±»å‹ã€‚ä»ä¸€ä¸ªå¯¹è±¡è®¿é—®å¤šä¸ªå±æ€§ç›¸å½“äºåˆ†åˆ«è®¿é—®æ¯ä¸ªå±æ€§ï¼Œç„¶åç”¨å®ƒä»¬çš„ç»“æœæ„é€ ä¸€ä¸ªè”åˆç±»å‹ï¼š

```ts
type NameOrAge = User["name"] | User["age"]; // => string | number
```

åªæ˜¯å˜å¾—æ›´ç®€æ´äº†ï¼[^2]


## `keyof` å…³é”®å­—


`keyof` å…³é”®å­—å¯ä»¥è®©ä½ è·å–å¯¹è±¡ç±»å‹ä¸­**æ‰€æœ‰å±æ€§**çš„è”åˆã€‚å®ƒå¯ä»¥æ”¾åœ¨ä»»ä½•å¯¹è±¡ä¹‹å‰ï¼š

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};

type Keys = keyof User; // "name" | "age" | "role"
```

ç”±äº `keyof` è¿”å›å­—ç¬¦ä¸²ç±»å‹çš„**è”åˆ**ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä¸æ–¹æ‹¬å·ç¬¦å·ç»“åˆèµ·æ¥ä»¥è·å–æ­¤å¯¹è±¡ä¸­**æ‰€æœ‰å€¼**çš„ç±»å‹çš„è”åˆï¼

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};

type UserValues = User[keyof User]; //  string | number | "admin" | "standard"
```

è¿™æ˜¯ä¸€ä¸ªéå¸¸å¸¸è§çš„ç”¨ä¾‹ï¼Œæˆ‘ä»¬ç»å¸¸å®šä¹‰ä¸€ä¸ª `ValueOf` **æ³›å‹ç±»å‹**æ¥æŠ½è±¡è¿™ä¸ªæ¨¡å¼ï¼š

```ts
type ValueOf<Obj> = Obj[keyof Obj];

type UserValues = ValueOf<User>; //  string | number | "admin" | "standard"
```

æ³›å‹æ˜¯ **type-level å‡½æ•°**ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä»»ä½•å¯¹è±¡ç±»å‹é‡ç”¨è¿™ä¸ªé€»è¾‘ï¼ ğŸ‰


## å¯é€‰å±æ€§

å¯¹è±¡ç±»å‹å¯ä»¥å®šä¹‰å¯é€‰çš„å±æ€§ã€‚å°†å±æ€§è®¾ç½®ä¸ºå¯é€‰çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `?:` é”®ä¿®é¥°ç¬¦ï¼š

```ts
type BlogPost = { title: string; tags?: string[] };
//                                   ^ this property is optional!

// âœ… No `tags` property
const blogBost1: BlogPost = { title: "introduction" };

// âœ… `tags` contains a list of strings
const blogBost2: BlogPost = {
  title: "part 1",
  tags: ["#easy", "#beginner-friendly"],
};
```

ä½†æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€äº›ç‰¹æ®Šçš„è¯­æ³•ï¼Œå®ƒçœ‹èµ·æ¥åƒè”åˆç±»å‹ï¼Œå¦‚ `T | undefined` ã€‚

```ts
type BlogPost = { title: string; tags: string[] | undefined };
```

è¿™æ˜¯å› ä¸ºå¦‚ä¸Šå®šä¹‰çš„å¯¹è±¡å¿…é¡»ä¸ºå…¶ç±»å‹ä¸­å­˜åœ¨çš„æ‰€æœ‰å±æ€§å®šä¹‰å€¼ã€‚ TypeScript ä¼šè¦æ±‚æˆ‘ä»¬æ˜¾å¼åœ°ä¸º undefined åˆ†é…ä¸€ä¸ª `tags` å±æ€§ï¼š

```ts
const blogBost1: BlogPost = { title: "part 1" };
//             ^ âŒ type error: the `tags` key is missing.

// âœ…
const blogBost2: BlogPost = { title: "part 1", tags: undefined };
```

å¿…é¡»å°†æ‰€æœ‰å¯é€‰å±æ€§åˆ†é…ç»™ `undefined` å¹¶ä¸æ–¹ä¾¿ã€‚æ‰€ä»¥å‘Šè¯‰ TypeScript å¯ä»¥çœç•¥æŸä¸ªå±æ€§æ˜¯ä¸€ç§æ›´å¥½çš„æ–¹æ³•ï¼

## ä½¿ç”¨ intersections (&) åˆå¹¶å¯¹è±¡ç±»å‹


ä¸ºäº†ä½¿æˆ‘ä»¬çš„ä»£ç æ›´åŠ æ¨¡å—åŒ–ï¼Œç»å¸¸å°†ç±»å‹å®šä¹‰æ‹†åˆ†ä¸ºå¤šä¸ªå¯¹è±¡ç±»å‹ã€‚è®©æˆ‘ä»¬å°†æˆ‘ä»¬çš„ `User` ç±»å‹æ‹†åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼š

```ts
type WithName = { name: string };
type WithAge = { age: number };
type WithRole = { role: "admin" | "standard" };
```

ç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•å°†å®ƒä»¬é‡æ–°ç»„åˆæˆä¸€ä¸ªç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºæ­¤ä½¿ç”¨ **intersection** (&) ï¼š

```ts
type User = WithName & WithAge & WithRole;

type Organization = WithName & WithAge; // organizations don't have a role
```

æˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­å·²ç»çœ‹åˆ°ï¼Œ**intersection** åˆ›å»ºçš„ç±»å‹å…·æœ‰äº¤é›†ç±»å‹çš„**æ‰€æœ‰å±æ€§**ï¼Œå› æ­¤ `User` çš„è¿™ä¸ªæ–°å®šä¹‰ç­‰åŒäºä¸Šé¢çš„ `User`ã€‚


## å¯¹è±¡çš„äº¤é›†å’Œé”®çš„å¹¶é›†

ç­‰ç­‰ï¼Œå¦‚æœç±»å‹ `{a: string, b: number}` æ˜¯ `{a: string}` å’Œ `{b: number}` çš„äº¤é›†ï¼Œ**ä¸ºä»€ä¹ˆè¿™ä¸ªç±»å‹è¿˜åŒ…å«äº†å®ƒä»¬é”®çš„å¹¶é›† `'a' | 'b'` ï¼Ÿ**ğŸ¤”

æˆ‘çŸ¥é“è¿™è®©æŸäº›äººæ„Ÿåˆ°å›°æƒ‘ï¼Œå¦ä¸€éƒ¨åˆ†äººåˆ™è§‰å¾—å¾ˆç¬¦åˆç›´è§‰ï¼Œè®©æˆ‘æ¥æŠŠè¿™ä¸ªè¯´æ¸…æ¥šä¸€äº›ã€‚

åŸå› å¦‚ä¸‹ï¼š**æˆ‘ä»¬å¹¶ä¸æ˜¯å¯¹å®ƒä»¬çš„é”®è¿›è¡Œäº¤é›†ï¼Œè€Œæ˜¯å¯¹å®ƒä»¬çš„å­é›†åˆè¿›è¡Œäº¤é›†çš„æ“ä½œ**ã€‚

ç”±äºå…·æœ‰**é¢å¤–**é”®çš„å¯¹è±¡ç±»å‹**å¯åˆ†é…**ç»™å…·æœ‰**è¾ƒå°‘é”®**çš„å¯¹è±¡ç±»å‹ï¼Œå› æ­¤åœ¨é›†åˆ `{a: string}` ä¸­å­˜åœ¨åŒ…å«ç±»å‹ä¸º `number` çš„é”® `b` çš„å¯¹è±¡ã€‚åœ¨é›†åˆ `{b: number}` ä¸­ä¹Ÿæœ‰åŒ…å« `string` ç±»å‹çš„é”® `a` çš„å¯¹è±¡ã€‚

å› æ­¤é›†åˆ `{a: string}` å’Œé›†åˆ `{b: number}` ç›¸äº¤çš„ç»“æœæ˜¯**åŒæ—¶å±äºè¿™ä¸¤ä¸ªé›†åˆ**çš„å€¼ï¼Œè¡¨ç¤ºä¸º `{a: string, b: number}` ã€‚

![3](./img/03-objects-and-records/3.svg)

äº‹å®è¯æ˜ï¼Œä¸¤ä¸ªå¯¹è±¡ç±»å‹çš„äº¤é›†åŒ…å«å®ƒä»¬**é”®çš„å¹¶é›†**ï¼š

```ts
type A = { a: string };
type KeyOfA = keyof A; // => 'a'

type B = { b: number };
type KeyOfB = keyof B; // => 'b'

type C = A & B;
type KeyOfC = keyof C; // => 'a' | 'b'
```

ç›¸åï¼Œä¸¤ä¸ªå¯¹è±¡ç±»å‹çš„å¹¶é›†åŒ…å«å®ƒä»¬çš„é”®çš„äº¤é›†ï¼š

```ts
type A = { a: string; c: boolean };
type KeyOfA = keyof A; // => 'a' | 'c'

type B = { b: number; c: boolean };
type KeyOfB = keyof B; // => 'b' | 'c'

type C = A | B;
type KeyOfC = keyof C; // => ('a' | 'c') & ('b' | 'c') <=> 'c'
```

å¦ä¸€ç§æ€è€ƒæ–¹å¼æ˜¯ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªç±»å‹ `A` æˆ–ç±»å‹ `B` çš„å€¼ï¼Œé‚£ä¹ˆåœ¨è¿™ç§æƒ…å†µä¸‹å”¯ä¸€å¯èƒ½å‡ºç°çš„é”®æ˜¯ `c`ã€‚

è¿™æ˜¯ä¸€èˆ¬è§„åˆ™ï¼š

```ts
keyof (A & B) = (keyof A) | (keyof B)
```

```ts
keyof (A | B) = (keyof A) & (keyof B)
```

è¿™æœ‰ç‚¹å¾®å¦™ï¼Œæˆ‘å¸Œæœ›è¿™æ˜¯æœ‰å¸®åŠ©çš„ï¼

## å¯¹è±¡ç›¸äº¤çš„ç‰¹æ®Šæƒ…å†µ

ä½¿ç”¨ intersections åˆå¹¶å¯¹è±¡æœ‰ä¸¤ä¸ªç‰¹æ®Šæƒ…å†µã€‚

**é¦–å…ˆ**ï¼Œintersections **é€’å½’åœ°**åº”ç”¨äºæ‰€æœ‰å¯¹è±¡å±æ€§ï¼Œå› æ­¤å¦‚æœæŸä¸ªå±æ€§åŒæ—¶å­˜åœ¨äºä¸¤ç§ç±»å‹ä¸Šï¼Œ**å®ƒä¹Ÿä¼šè¢«ç›¸äº¤**ï¼

è¿™å¯èƒ½ä¼šäº§ç”Ÿæ„æƒ³ä¸åˆ°çš„ç»“æœã€‚ç‰¹åˆ«æ˜¯å¦‚æœå…±äº«å±æ€§åŒ…å«å½¼æ­¤ä¸é‡å çš„ç±»å‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå°†äº§ç”Ÿ `never` ç±»å‹ï¼ˆä¹Ÿç§°ä¸º[ç©ºé›†](/02-types-are-just-data#never--the-empty-set)ï¼‰ï¼š

```ts
type WithName = { name: string; id: string };
type WithAge = { age: number; id: number };
type User = WithName & WithAge;

type Id = User["id"]; // => string & number <=> never
```

å¦‚æœæ‚¨ç¡®å®çŸ¥é“æ‚¨çš„å¯¹è±¡æ²¡æœ‰é‡å å±æ€§ï¼Œé‚£ä¹ˆä½¿ç”¨ intersections åˆå¹¶å®ƒä»¬å°±å®Œå…¨æ²¡é—®é¢˜äº†ã€‚

**å…¶æ¬¡**ï¼Œå¯¹è±¡çš„äº¤é›†æœ‰å¯èƒ½å¯¹æ€§èƒ½äº§ç”Ÿå½±å“[^3]ã€‚å¦‚æœæ‚¨çš„ç±»å‹å®šä¹‰æ˜¯é™æ€çš„ï¼ˆå®ƒä»¬ä¸ä¾èµ–äºç±»å‹å‚æ•°ï¼‰ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `interface` å’Œ `extends` å…³é”®å­—è·å¾—ç›¸åŒçš„ç»“æœï¼š

```ts
interface User extends WithName, WithAge, WithRole {}
interface Organization extends WithName, WithAge {}
```

[`interface` å…·æœ‰æ›´å¥½çš„æ€§èƒ½](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections)ï¼Œä½†åªèƒ½é™æ€å®šä¹‰ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æ— æ³•åœ¨ type-level å‡½æ•°ä¸­åˆ›å»ºå®ƒä»¬ã€‚

## è®°å½•ç±»å‹

å°±åƒå¯¹è±¡ç±»å‹ä¸€æ ·ï¼Œè®°å½•ä¹Ÿè¡¨ç¤ºå¯¹è±¡çš„é›†åˆã€‚ä¸åŒä¹‹å¤„åœ¨äºè®°å½•ç±»å‹çš„**æ‰€æœ‰é”®**çš„**ç±»å‹éƒ½æ˜¯ç›¸åŒçš„**ã€‚

ä¸€ä¸ªå¸ƒå°”å€¼è®°å½•ç±»å‹å®šä¹‰å¦‚ä¸‹ï¼š

```ts
type RecordOfBooleans = { [key: string]: boolean };
```

æ‚¨å¯ä»¥å°†å…¶ç†è§£ä¸ºâ€œå¯åˆ†é…ç»™ `string` çš„ä»»ä½•é”®éƒ½å…·æœ‰ `boolean` ç±»å‹çš„å€¼â€ã€‚

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å†…ç½®çš„ `Record` æ³›å‹æ¥å®šä¹‰è®°å½•ç±»å‹ï¼š

```ts
type RecordOfBooleans = Record<string, boolean>;
```

`Record` å®šä¹‰å¦‚ä¸‹ï¼š

```ts
type Record<K, V> = { [key in K]: V };
```

Notice the in keyword. This is using a feature called Mapped Types, which we will cover in more detail in a dedicated chapter. Briefly, in lets us assign a type of value for every key in the union K.

æ³¨æ„ `in` è¿™ä¸ªå…³é”®å­—ã€‚è¿™æ˜¯[æ˜ å°„ç±»å‹](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å°†åœ¨ä¸“é—¨çš„ç« èŠ‚ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»ã€‚ç®€è€Œè¨€ä¹‹ï¼Œ `in` è®©æˆ‘ä»¬ä¸ºè”åˆ `K` ä¸­çš„æ¯ä¸ªé”®åˆ†é…ä¸€ç§ç±»å‹çš„å€¼ã€‚

åœ¨æˆ‘ä»¬ä¹‹å‰çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°† `string` ç±»å‹ä½œä¸º `K` ä¼ é€’ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ `string` çš„è”åˆç±»å‹ï¼š

```ts
type InputState = Record<"valid" | "edited" | "focused", boolean>;
```

æˆ–è€…ä¸ä½¿ç”¨ `Record`ï¼š

```ts
type InputState = { [key in "valid" | "edited" | "focused"]: boolean };
```

ç­‰ä»·äºï¼š

```ts
type InputState = { valid: boolean; edited: boolean; focused: boolean };
```

å¯¹äº type-level çš„ç¨‹åºï¼Œè®°å½•ä¸ç®—æœ‰è¶£çš„æ•°æ®ç»“æ„ï¼Œå®ƒåªèƒ½åŒ…å«å•ä¸€çš„ç±»å‹ï¼Œè€Œå¯¹è±¡å´å¯ä»¥åŒ…å«å¾ˆå¤šä¸åŒçš„ç±»å‹ã€‚å¤§å¤šæ—¶å€™ï¼Œæˆ‘ä»¬éƒ½åªéœ€è¦**æå–**è®°å½•ä¸­å€¼çš„ç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `[string]` æ¥å®ç°ï¼š

```ts
type ValueType = RecordOfBooleans[string]; // => boolean
```

æˆ‘ä»¬åŒæ—¶è¯»å–æ‰€æœ‰å¯åˆ†é…ç»™ `string` ç±»å‹çš„é”®ã€‚å› ä¸ºå®ƒä»¬éƒ½åŒ…å« `boolean`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ°äº†`boolean`ç±»å‹ã€‚

## è¾…åŠ©å‡½æ•°



<CodeEditor
  height={500}
  defaultValue={[tavPracticeArr[13], tavPracticeArr[14]]}
/>

[^1]: This is why Object.keys(...) returns a string[] and not a (keyof Obj)[] by the way. (keyof Obj)[] would be incorrect because Object.keys(...) could return strings that are not assignable to keyof Obj.

[^2]: The real reason why it's possible to read several properties at once using a union type is because the type level expression User["name"] and the value level expression user["name"] work differently. Instead of finding the key equal to "name" in the type User, TypeScript tries to find every key in User that is assignable to the type "name"!
If we write User["name" | "age"], TS will find all keys assignable to the type "name" | "age" and return their value types. Pretty cool right?

[^3]: Using too many intersection types can be detrimental to type-checking performance. In the previous chapter (Types are just data), I explained that intersection types were data structures. Instead of actually merging object types into one single entity, they keep each individual object type in memory in a sort of internal list of intersected types. Because of this, the type-checker needs to allocate more memory and will take more time to check if object types are assignable because it will need to traverse this internal list to check each object type one by one.

Interfaces are better in that regard because they actually merge type definitions into one flat structure. Their downside is that they cannot be created dynamically, say from type parameters inside a generic. That's why using intersections to merge objects is still a useful trick to know!


export default ({ children }) => (
  <PageLayout prev={PostArrary[0]} next={PostArrary[2]} meta={meta}>
    {children}
  </PageLayout>
);
