import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { tavPracticeArr } from '../practice/index';
import { PostArrary } from '../postInfos';

export const meta = {};

# Objects & Records

在 Type-level TypeScript 中，Objects 和 Records 是两种最常用的**数据结构**。它们是我们 type-level **算法**的基础，了解它们的工作原理十分重要。我能肯定你早已使用过 Objects 和 Records ，但我希望本章能加深你对它们代表的意义的**理解**，以及展示一些**不常用的使用场景**。

```ts
type SomeObject = { key1: boolean; key2: number };

type SomeRecord = { [key: string]: number };
```

在我们开始之前，让我再次提醒你一下，我们[上一章节](/02-types-are-just-data)讨论过的重要概念。在深入探讨[类型和集合理论之间的关系](/02-types-are-just-data#types-are-sets)之前，我们简要介绍了类型的**五个主要类别** —— **基础**类型、**字面量**类型、**数据结构**类型、**联合**类型和**交集**类型。

我们发现**类型代表一组值**。就像集合一样，类型可以包含其他类型，我们把这种关系称之**子类型**。

![1](./img/03-objects-and-records/1.svg)

最后，我们学习了两种特殊的类型： `never` - **空集**， 和 `unkown` - **其它所有类型的超集**。

现在，让我们关注上一章节中提到的**四种数据结构类型**中的**两种**：**Objects** 和 **Records** ：

```ts
type FourKindsOfDataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
```

## Object 类型

Object 类型定义 **JavaScript 的对象集合**。创建 Object 类型的语法与我们创建常规对象的方式非常相似：

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};
```

事实上，它们是 JS 对象在 type-level 的等价物。就像 JS 对象一样，它可以包含我们想要的任意数量的属性，并且每个属性都由一个**唯一的键**索引。需要注意的是，每个键可以包含**不同**的类型： `name` 键包含 `string` 类型， `age` 键包含 `numner` 类型。

我们创建的 `User` 类型是具有`name`、`age` 和包含正确类型值的 `role` 属性的所有对象的集合：

```ts
// ✅ this object is in the `User` set.
const gabriel: User = {
  name: "Gabriel",
  role: "admin",
  age: 28,
};

// ❌
const bob: User = {
  name: "Bob",
  age: 45,
  // <- the `role` key is missing.
};

// ❌
const peter: User = {
  name: "Peter",
  role: "standard",
  age: "45" /* <- the `age` key should be of type `number`,
                   but it's assigned to a `string`. */,
};
```

**但是具有额外属性的对象呢**？它们可以分配给我们的 `User` 类型吗？

嗯，**可以……也不可以**。让我解释一下！

## 对象的可分配性

如果您尝试将对象分配给具有显式类型注释的变量，就像我们到目前为止所做的那样，TypeScript 将**拒绝**额外的属性：

```ts
const alice: User = {
  name: "Alice",
  age: 35,
  role: "admin",
  bio: "...",
/* ~~~~~~~~~  
       ^  ❌ This doesn't type-check. */
};
```

这是你将得到的完整错误：

```ts
Object literal may only specify known properties, and 'bio' does not exist in type 'User'. (2322)
```

**对象字面量**指的是你使用大括号 `{}` 语法**內联**定义的对象。

如果我们将具有额外属性的，**预先定义好的**对象赋值给 `alice` 会报错吗？

```ts
const looksLikeAUser = {
  name: "Alice",
  age: 35,
  role: "admin" as const,
  bio: "...", // <- extra prop!
};

// ✅ This works just fine!
const alice: User = looksLikeAUser;
```

TypeScript 不会报错。

所以最终的答案是**具有额外属性的对象可以分配给具有更少属性的对象**，但是在**对象被内联定义**的上下文中，TypeScript 有**额外的规则**来确保我们不会错误地分配我们之后无法使用的属性，因为类型检查会禁止我们这样做。

![2](./img/03-objects-and-records/2.svg)

这意味着，你**不能保证**某种类型的对象**不包含**额外的属性！[^1] 一个 Object 类型是一个**至少**包含它所定义的所有属性的对象的集合。

现在，让我们看看，可以用 type-level 的对象做些什么？

## 读取属性

要访问一个属性的类型，我们可以使用方括号：

```ts
type User = { name: string; age: number; role: "admin" | "standard" };

type Age = User["age"]; // => number
type Role = User["role"]; // => "admin" | "standard"
```

但是点不会起作用！

```ts
type Age = User.age;
//             ^ ❌ syntax error!
```

没关系。无论如何，方括号表示法和点表示法在 value-level 上是等价的。

## 一次读取多个属性

您可能已经注意到，在 `User["age"]` 等表达式中，键 (`"age"`) 是[**字面量类型**](/02-types-are-just-data#literal-types)。如果您尝试使用**联合类型**，你认为会发生什么？

```ts
type User = { name: string; age: number; role: "admin" | "standard" };

type NameOrAge = User["name" | "age"]; // => string | number
```

嗯，它是有效的！就好像我们**同时**访问 `"name"` 和 `"age"` 属性一样，然后会得到一个包含它们的类型的联合类型。从一个对象访问多个属性相当于分别访问每个属性，然后用它们的结果构造一个联合类型：

```ts
type NameOrAge = User["name"] | User["age"]; // => string | number
```

只是变得更简洁了！[^2]


## `keyof` 关键字


`keyof` 关键字可以让你获取对象类型中**所有属性**的联合。它可以放在任何对象之前：

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};

type Keys = keyof User; // "name" | "age" | "role"
```

由于 `keyof` 返回字符串类型的**联合**，我们可以将它与方括号符号结合起来以获取此对象中**所有值**的类型的联合！

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};

type UserValues = User[keyof User]; //  string | number | "admin" | "standard"
```

这是一个非常常见的用例，我们经常定义一个 `ValueOf` **泛型类型**来抽象这个模式：

```ts
type ValueOf<Obj> = Obj[keyof Obj];

type UserValues = ValueOf<User>; //  string | number | "admin" | "standard"
```

泛型是 **type-level 函数**。现在，我们可以对任何对象类型重用这个逻辑！ 🎉


## 可选属性

对象类型可以定义可选的属性。将属性设置为可选的方法是使用 `?:` 键修饰符：

```ts
type BlogPost = { title: string; tags?: string[] };
//                                   ^ this property is optional!

// ✅ No `tags` property
const blogBost1: BlogPost = { title: "introduction" };

// ✅ `tags` contains a list of strings
const blogBost2: BlogPost = {
  title: "part 1",
  tags: ["#easy", "#beginner-friendly"],
};
```

But why do we need some special syntax where it looks like a union type like T | undefined would do the trick?

但是为什么我们需要一些特殊的语法，它看起来像联合类型，如 `T | undefined` 会让上面的代码通过类型检查吗？

```ts
type BlogPost = { title: string; tags: string[] | undefined };
```

这是因为对象必须为其类型中存在的所有键定义值。 TypeScript 会要求我们显式地为 undefined 分配一个标签键：


<CodeEditor
  height={500}
  defaultValue={[tavPracticeArr[13], tavPracticeArr[14]]}
/>

[^1]: This is why Object.keys(...) returns a string[] and not a (keyof Obj)[] by the way. (keyof Obj)[] would be incorrect because Object.keys(...) could return strings that are not assignable to keyof Obj.

[^2]: The real reason why it's possible to read several properties at once using a union type is because the type level expression User["name"] and the value level expression user["name"] work differently. Instead of finding the key equal to "name" in the type User, TypeScript tries to find every key in User that is assignable to the type "name"!
If we write User["name" | "age"], TS will find all keys assignable to the type "name" | "age" and return their value types. Pretty cool right?

export default ({ children }) => (
  <PageLayout prev={PostArrary[0]} next={PostArrary[2]} meta={meta}>
    {children}
  </PageLayout>
);
