import PageLayout from '../layouts/PageLayout';
import CodeEditor from '../components/CodeEditor';
import ItalicTitle from '../components/ItalicTitle';
import { PostCards } from '../components/Card';
import { tavPracticeArr } from '../practice/index';
import { PostArrary } from '../postInfos';

export const meta = {};

# Objects & Records

在 Type-level TypeScript 中，Objects 和 Records 是两种最常用的**数据结构**。它们是我们 type-level **算法**的基础，了解它们的工作原理十分重要。我能肯定你早已使用过 Objects 和 Records ，但我希望本章能加深你对它们代表的意义的**理解**，以及展示一些**不常用的使用场景**。

```ts
type SomeObject = { key1: boolean; key2: number };

type SomeRecord = { [key: string]: number };
```

在我们开始之前，让我再次提醒你一下，我们[上一章节](/02-types-are-just-data)讨论过的重要概念。在深入探讨[类型和集合理论之间的关系](/02-types-are-just-data#types-are-sets)之前，我们简要介绍了类型的**五个主要类别** —— **基础**类型、**字面量**类型、**数据结构**类型、**联合**类型和**交集**类型。

我们发现**类型代表一组值**。就像集合一样，类型可以包含其他类型，我们把这种关系称之**子类型**。

![1](./img/03-objects-and-records/1.svg)

最后，我们学习了两种特殊的类型： `never` - **空集**， 和 `unkown` - **其它所有类型的超集**。

现在，让我们关注上一章节中提到的**四种数据结构类型**中的**两种**：**Objects** 和 **Records** ：

```ts
type FourKindsOfDataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
```

## Object 类型

Object 类型定义 **JavaScript 的对象集合**。创建 Object 类型的语法与我们创建常规对象的方式非常相似：

```ts
type User = {
  name: string;
  age: number;
  role: "admin" | "standard";
};
```

事实上，它们是 JS 对象在 type-level 的等价物。就像 JS 对象一样，它可以包含我们想要的任意数量的属性，并且每个属性都由一个**唯一的键**索引。需要注意的是，每个键可以包含**不同**的类型： `name` 键包含 `string` 类型， `age` 键包含 `numner` 类型。

我们创建的 `User` 类型是具有`name`、`age` 和包含正确类型值的 `role` 属性的所有对象的集合：

```ts
// ✅ this object is in the `User` set.
const gabriel: User = {
  name: "Gabriel",
  role: "admin",
  age: 28,
};

// ❌
const bob: User = {
  name: "Bob",
  age: 45,
  // <- the `role` key is missing.
};

// ❌
const peter: User = {
  name: "Peter",
  role: "standard",
  age: "45" /* <- the `age` key should be of type `number`,
                   but it's assigned to a `string`. */,
};
```

**但是具有额外属性的对象呢**？它们可以分配给我们的 `User` 类型吗？

嗯，**可以……也不可以**。让我解释一下！

## 对象的可分配性

如果您尝试将对象分配给具有显式类型注释的变量，就像我们到目前为止所做的那样，TypeScript 将**拒绝**额外的属性：

```ts
const alice: User = {
  name: "Alice",
  age: 35,
  role: "admin",
  bio: "...",
/* ~~~~~~~~~  
       ^  ❌ This doesn't type-check. */
};
```

这是你将得到的完整错误：

```ts
Object literal may only specify known properties, and 'bio' does not exist in type 'User'. (2322)
```

**对象字面量**指的是你使用大括号 `{}` 语法**內联**定义的对象。

如果我们将具有额外属性的，**预先定义好的**对象赋值给 `alice` 会报错吗？

```ts
const looksLikeAUser = {
  name: "Alice",
  age: 35,
  role: "admin" as const,
  bio: "...", // <- extra prop!
};

// ✅ This works just fine!
const alice: User = looksLikeAUser;
```

TypeScript 不会报错。

所以最终的答案是**具有额外属性的对象可以分配给具有更少属性的对象**，但是在**对象被内联定义**的上下文中，TypeScript 有**额外的规则**来确保我们不会错误地分配我们之后无法使用的属性，因为类型检查会禁止我们这样做。

![2](./img/03-objects-and-records/2.svg)

This means that you have absolutely no guarantee that an object of some type does not contain extra props! An object type is the set of objects with at least all properties it defines.

这意味着，你**不能保证**某种类型的对象**不包含**额外的属性！[^1] 一个 Object 类型是一个**至少**包含它所定义的所有属性的对象的集合。

现在，让我们看看，可以用 type-level 的对象做些什么？


<CodeEditor
  height={500}
  defaultValue={[tavPracticeArr[13], tavPracticeArr[14]]}
/>

[^1]: This is why Object.keys(...) returns a string[] and not a (keyof Obj)[] by the way. (keyof Obj)[] would be incorrect because Object.keys(...) could return strings that are not assignable to keyof Obj.

export default ({ children }) => (
  <PageLayout prev={PostArrary[0]} next={PostArrary[2]} meta={meta}>
    {children}
  </PageLayout>
);
